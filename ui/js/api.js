/**
 * API functions for the Alpaca Trading Dashboard
 */

let positions = [];
let historicalTrades = [];
let currentOrders = [];

/**
 * Load Alpaca credentials from config
 */
async function loadCredentials() {
    // Credentials are loaded from config.js (generated by load_config.py)
    if (!ALPACA_CONFIG.apiKey || !ALPACA_CONFIG.secretKey) {
        throw new Error('Alpaca credentials not configured. Run load_config.py first.');
    }
}

/**
 * Load current positions from Alpaca
 */
async function loadPositions() {
    try {
        const response = await fetch(`${ALPACA_CONFIG.baseUrl}/v2/positions`, {
            headers: {
                'APCA-API-KEY-ID': ALPACA_CONFIG.apiKey,
                'APCA-API-SECRET-KEY': ALPACA_CONFIG.secretKey
            }
        });

        if (!response.ok) {
            throw new Error(`Failed to load positions: ${response.statusText}`);
        }

        positions = await response.json();
        return positions;
    } catch (error) {
        console.error('Error loading positions:', error);
        throw error;
    }
}

/**
 * Load historical trades/orders
 */
async function loadHistoricalTrades() {
    try {
        // Get all orders with status=all to include filled and cancelled orders
        const response = await fetch(`${ALPACA_CONFIG.baseUrl}/v2/orders?status=all&limit=100`, {
            headers: {
                'APCA-API-KEY-ID': ALPACA_CONFIG.apiKey,
                'APCA-API-SECRET-KEY': ALPACA_CONFIG.secretKey
            }
        });

        if (!response.ok) {
            throw new Error(`Failed to load trades: ${response.statusText}`);
        }

        const orders = await response.json();
        
        // Group orders by symbol and filter for completed trades
        const tradesBySymbol = {};
        orders.forEach(order => {
            if (order.status === 'filled' && order.symbol) {
                if (!tradesBySymbol[order.symbol]) {
                    tradesBySymbol[order.symbol] = [];
                }
                tradesBySymbol[order.symbol].push(order);
            }
        });

        // Convert to array of unique symbols with trade history
        historicalTrades = Object.keys(tradesBySymbol).map(symbol => ({
            symbol,
            orders: tradesBySymbol[symbol]
        }));

        return historicalTrades;
    } catch (error) {
        console.error('Error loading trades:', error);
        throw error;
    }
}

/**
 * Load orders for a specific symbol
 */
async function loadOrdersForSymbol(symbol) {
    try {
        const url = `${ALPACA_CONFIG.baseUrl}/v2/orders?symbols=${symbol}&status=all&limit=50`;
        console.log('Fetching orders from:', url);
        
        const response = await fetch(url, {
            headers: {
                'APCA-API-KEY-ID': ALPACA_CONFIG.apiKey,
                'APCA-API-SECRET-KEY': ALPACA_CONFIG.secretKey
            }
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error('Orders API error:', response.status, errorText);
            throw new Error(`Failed to load orders: ${response.status} ${response.statusText}`);
        }

        const orders = await response.json();
        console.log(`Orders for ${symbol}:`, orders);
        
        // Store orders for overlay
        currentOrders = orders;
        
        return orders;
    } catch (error) {
        console.error('Error loading orders:', error);
        throw error;
    }
}

/**
 * Get current positions
 */
function getPositions() {
    return positions;
}

/**
 * Get historical trades
 */
function getHistoricalTrades() {
    return historicalTrades;
}

/**
 * Get current orders
 */
function getCurrentOrders() {
    return currentOrders;
}
