/**
 * API functions for the Alpaca Trading Dashboard
 */

let positions = [];
let historicalTrades = [];
let currentOrders = [];
let accountData = null;

/**
 * Load Alpaca credentials from config
 */
async function loadCredentials() {
    // Credentials are loaded from config.js (generated by load_config.py)
    if (!ALPACA_CONFIG.apiKey || !ALPACA_CONFIG.secretKey) {
        throw new Error('Alpaca credentials not configured. Run load_config.py first.');
    }
}

/**
 * Load current positions from Alpaca
 */
async function loadPositions() {
    try {
        const response = await fetch(`${ALPACA_CONFIG.baseUrl}/v2/positions`, {
            headers: {
                'APCA-API-KEY-ID': ALPACA_CONFIG.apiKey,
                'APCA-API-SECRET-KEY': ALPACA_CONFIG.secretKey
            }
        });

        if (!response.ok) {
            throw new Error(`Failed to load positions: ${response.statusText}`);
        }

        positions = await response.json();
        return positions;
    } catch (error) {
        console.error('Error loading positions:', error);
        throw error;
    }
}

/**
 * Load historical trades/orders
 */
async function loadHistoricalTrades() {
    try {
        // Get all orders with status=all to include filled and cancelled orders
        const response = await fetch(`${ALPACA_CONFIG.baseUrl}/v2/orders?status=all&limit=100`, {
            headers: {
                'APCA-API-KEY-ID': ALPACA_CONFIG.apiKey,
                'APCA-API-SECRET-KEY': ALPACA_CONFIG.secretKey
            }
        });

        if (!response.ok) {
            throw new Error(`Failed to load trades: ${response.statusText}`);
        }

        const orders = await response.json();
        
        // Group orders by symbol and filter for completed trades
        const tradesBySymbol = {};
        orders.forEach(order => {
            if (order.status === 'filled' && order.symbol) {
                if (!tradesBySymbol[order.symbol]) {
                    tradesBySymbol[order.symbol] = [];
                }
                tradesBySymbol[order.symbol].push(order);
            }
        });

        // Convert to array of unique symbols with trade history
        historicalTrades = Object.keys(tradesBySymbol).map(symbol => ({
            symbol,
            orders: tradesBySymbol[symbol]
        }));

        return historicalTrades;
    } catch (error) {
        console.error('Error loading trades:', error);
        throw error;
    }
}

/**
 * Load account data from Alpaca
 */
async function loadAccountData() {
    try {
        const response = await fetch(`${ALPACA_CONFIG.baseUrl}/v2/account`, {
            headers: {
                'APCA-API-KEY-ID': ALPACA_CONFIG.apiKey,
                'APCA-API-SECRET-KEY': ALPACA_CONFIG.secretKey
            }
        });

        if (!response.ok) {
            throw new Error(`Failed to load account data: ${response.statusText}`);
        }

        accountData = await response.json();
        console.log('Account data loaded:', accountData);
        return accountData;
    } catch (error) {
        console.error('Error loading account data:', error);
        throw error;
    }
}

/**
 * Load all current orders (for stop loss analysis)
 */
async function loadCurrentOrders() {
    try {
        const response = await fetch(`${ALPACA_CONFIG.baseUrl}/v2/orders?status=all&limit=100`, {
            headers: {
                'APCA-API-KEY-ID': ALPACA_CONFIG.apiKey,
                'APCA-API-SECRET-KEY': ALPACA_CONFIG.secretKey
            }
        });

        if (!response.ok) {
            throw new Error(`Failed to load current orders: ${response.statusText}`);
        }

        currentOrders = await response.json();
        console.log('Current orders loaded:', currentOrders.length);
        return currentOrders;
    } catch (error) {
        console.error('Error loading current orders:', error);
        throw error;
    }
}

/**
 * Load orders for a specific symbol
 */
async function loadOrdersForSymbol(symbol) {
    try {
        const url = `${ALPACA_CONFIG.baseUrl}/v2/orders?symbols=${symbol}&status=all&limit=50`;
        console.log('Fetching orders from:', url);
        
        const response = await fetch(url, {
            headers: {
                'APCA-API-KEY-ID': ALPACA_CONFIG.apiKey,
                'APCA-API-SECRET-KEY': ALPACA_CONFIG.secretKey
            }
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error('Orders API error:', response.status, errorText);
            throw new Error(`Failed to load orders: ${response.status} ${response.statusText}`);
        }

        const orders = await response.json();
        console.log(`Orders for ${symbol}:`, orders);
        
        // Store orders for overlay
        currentOrders = orders;
        
        return orders;
    } catch (error) {
        console.error('Error loading orders:', error);
        throw error;
    }
}

/**
 * Get current positions
 */
function getPositions() {
    return positions;
}

/**
 * Get historical trades
 */
function getHistoricalTrades() {
    return historicalTrades;
}

/**
 * Get current orders
 */
function getCurrentOrders() {
    return currentOrders;
}

/**
 * Get account data
 */
function getAccountData() {
    return accountData;
}

/**
 * Get account equity (total account value)
 */
function getAccountEquity() {
    if (!accountData) return 0;
    return parseFloat(accountData.equity) || 0;
}

/**
 * Get buying power (available cash for trading)
 */
function getBuyingPower() {
    if (!accountData) return 0;
    return parseFloat(accountData.buying_power) || 0;
}

/**
 * Check if a position has an active stop loss order
 */
function hasStopLossOrder(symbol) {
    if (!currentOrders || currentOrders.length === 0) {
        return false;
    }
    
    return currentOrders.some(order => 
        order.symbol === symbol && 
        order.order_type === 'stop' && 
        order.side === 'sell' && 
        (order.status === 'new' || order.status === 'accepted' || order.status === 'partially_filled')
    );
}
